expr -> expr1 expr0 .
expr0 -> xior expr1 expr0 .
expr0 -> .
expr1 -> expr2 expr10 .
expr10 -> and expr2 expr10 .
expr10 -> .
expr2 -> expr3 expr20 .
expr20 -> cmp expr3 expr20 .
expr20 -> .
expr3 -> expr4 expr30 .
expr30 -> plusminus expr4 expr30 .
expr30 -> .
expr4 -> expr5 expr40 .
expr40 -> multdivmod expr5 expr40 .
expr40 -> .
expr5 -> unop expr6 .
expr5 -> new type .
expr5 -> del expr6 .
expr5 -> [ type ] expr6 .
expr5 -> expr6 .
expr6 -> expr7 expr60 .
expr60 -> [ expr ] expr60 .
expr60 -> dot identifier expr60 .
expr60 -> .
expr7 -> ( expr ) .
expr7 -> idenexprmulti .
expr7 -> { stmtmulti : exprwhere } .
expr7 -> literal .
type -> void .
type -> bool .
type -> char .
type -> int .
type -> arr [ expr ] type .
type -> rec ( identypemulti ) .
type -> ptr type .
type -> identifier .
stmt -> expr stmt0 .
stmt0 -> .
stmt0 -> = expr .
stmt -> if expr then stmtmulti stmtelse end .
stmt -> while expr do stmtmulti end .
decl -> typ identifier : type .
decl -> var identifier : type .
decl -> fun identifier ( identypemulti ) : type exprassign .
idenexprmulti -> identifier idenexprmulti0 .
idenexprmulti0 -> ( exprmulti ) .
idenexprmulti0 -> .
exprwhere -> expr exprwhere0 .
exprwhere0 -> .
exprwhere0 -> where declmulti .
exprmulti -> expr exprmulti0 .
exprmulti -> .
exprmulti0 -> , expr exprmulti0 .
exprmulti0 -> .
exprassign -> .
exprassign -> = expr .
stmtelse -> else stmtmulti .
stmtelse -> .
stmtmulti -> stmt stmtmulti0 .
stmtmulti0 -> ; stmtmulti .
stmtmulti0 -> .
declmulti -> decl declmulti0 .
declmulti0 -> ; declmulti .
declmulti0 -> .
identypemulti -> identifier : type identypemulti0 .
identypemulti0 -> .
identypemulti0 -> , identypemulti .
