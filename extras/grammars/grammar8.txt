expr -> expr xior expr1 .
expr -> expr1.

expr1 -> expr1 and expr2 .
expr1 -> expr2 .

expr2 -> expr2 cmp expr3 .
expr2 -> expr3 .

expr3 -> expr3 plusminus expr4 .
expr3 -> expr4 .

expr4 -> expr4 multdivmod expr5 .
expr4 -> expr5 .

expr5 -> unop expr5 .
expr5 -> new type .
expr5 -> del expr5 .
expr5 -> [ type ] expr5 .
expr5 -> expr6 .

expr6 -> expr6 [ expr ] .
expr6 -> expr6 dot identifier .
expr6 -> expr7 .

expr7 -> ( expr ) .
expr7 -> idenexprmulti .
expr7 -> { stmtmulti : exprwhere } .
expr7 -> literal .


type -> void .
type -> bool .
type -> char .
type -> int .
type -> arr [ expr ] type .
type -> rec ( identypemulti ) .
type -> ptr type .
type -> identifier .

stmt -> expr stmt' .
stmt' -> .
stmt' -> = expr .
stmt -> if expr then stmtmulti stmtelse end .
stmt -> while expr do stmtmulti end .

decl -> typ identifier : type .
decl -> var identifier : type .
decl -> fun identifier ( identypemulti ) : type exprassign .

idenexprmulti -> identifier idenexprmulti' .
idenexprmulti' -> ( exprmulti ) .
idenexprmulti' -> .

exprwhere -> expr exprwhere' .
exprwhere' -> .
exprwhere' -> where declmulti .

exprmulti -> expr exprmulti' .
exprmulti -> .
exprmulti'-> , expr exprmulti' .
exprmulti' -> .

exprassign -> .
exprassign -> = expr .

stmtelse -> else stmtmulti .
stmtelse -> .

stmtmulti -> stmt stmtmulti' .
stmtmulti' -> ; stmtmulti .
stmtmulti' -> .

declmulti -> decl declmulti' .
declmulti' -> ; declmulti .
declmulti' -> .

identypemulti -> identifier : type identypemulti' .
identypemulti' -> .
identypemulti' -> , identypemulti .
