expr -> idenexprmulti expr0 .
expr -> { stmtmulti : exprwhere } expr0 .
expr -> literal .

expr -> expr1 expr0 .

expr0 -> xior expr1 expr0 .
expr0 -> .

expr1 -> expr2 expr10 .
expr10 -> and expr2 expr10 .
expr10 -> .

expr2 -> expr3 expr20 .
expr20 -> cmp expr3 expr20 .
expr20 -> .

expr3 -> expr4 expr30 .
expr30 -> plusminus expr4 expr30 .
expr30 -> .

expr4 -> expr50 expr40 .
expr40 -> multdivmod expr50 expr40 .
expr40 -> .

expr5 -> expr7 expr6 .
expr50 -> expr5 .
expr50 -> [ type ] expr5 .
expr50 -> unop expr5 .
expr50 -> new expr5 .
expr50 -> del expr5 .

expr6 -> .
expr6 -> dot identifier .
expr6 -> [ expr ] .

expr7 -> ( expr ) .



type -> void .
type -> bool .
type -> char .
type -> int .
type -> arr [ expr ] type .
type -> rec ( identypemulti ) .
type -> ptr type .
type -> identifier .

stmt -> expr stmt0 .
stmt0 -> .
stmt0 -> = expr .
stmt -> if expr then stmtmulti stmtelse end .
stmt -> while expr do stmtmulti end .

decl -> typ identifier : type .
decl -> var identifier : type .
decl -> fun identifier ( identypemulti ) : type exprassign .

idenexprmulti -> identifier idenexprmulti0 .
idenexprmulti0 -> ( exprmulti ) .
idenexprmulti0 -> .

exprwhere -> expr exprwhere0 .
exprwhere0 -> .
exprwhere0 -> where declmulti .

exprmulti -> expr exprmulti0 .
exprmulti -> .
exprmulti0 -> , expr exprmulti0 .
exprmulti0 -> .

exprassign -> .
exprassign -> = expr .

stmtelse -> else stmtmulti .
stmtelse -> .

stmtmulti -> stmt stmtmulti0 .
stmtmulti0 -> ; stmtmulti .
stmtmulti0 -> .

declmulti -> decl declmulti0 .
declmulti0 -> ; declmulti .
declmulti0 -> .

identypemulti -> identifier : type identypemulti0 .
identypemulti0 -> .
identypemulti0 -> , identypemulti .
